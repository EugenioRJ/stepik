# 5.5 Decimal number to Roman - Шаг 1

В римской системе счисления для обозначения чисел используются следующие символы (справа записаны числа, которым они соответствуют в десятичной системе счисления):

I = 1
V = 5
X = 10
L = 50
C = 100
D = 500
M = 1000

Будем использовать вариант, в котором числа 4, 9, 40, 90, 400 и 900 записываются как вычитание из большего числа меньшего: IV, IX, XL, XC, CD и CM, соответственно.

**Формат ввода**:

Строка, содержащая натуральное число n, 0 < n < 4000.

**Формат вывода**:

Строка, содержащая число, закодированное в римской системе счисления.

**Sample Input 1**:

1984

**Sample Output 1**:

MCMLXXXIV

**Sample Input 2**:

9

**Sample Output 2**:

IX

**Sample Input 3**:

3

**Sample Output 3**:

III

```
inp = str(input())
result = ''
romans = (
    ('C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', ''),
    ('X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', ''),
    ('I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', '')
)

for i in range(len(inp)):
    if i == 0 and len(inp) == 4:
        result += 'M' * int(inp[i])
    else:
        result += romans[(i - len(inp)) % 3][int(inp[i]) - 1]

print(result)
```

# 5.4 Roman number to decimal

В римской системе счисления для обозначения чисел используются следующие символы (справа записаны числа, которым они соответствуют в десятичной системе счисления):

I = 1
V = 5
X = 10
L = 50
C = 100
D = 500
M = 1000

Будем использовать вариант, в котором числа 4, 9, 40, 90, 400 и 900 записываются как вычитание из большего числа меньшего: IV, IX, XL, XC, CD и CM, соответственно.

Напишите программу, которая переводит число из римской в десятичную систему счисления.

**Формат ввода**:

Строка, содержащая число, закодированное в римской системе счисления. Гарантируется, что число меньше 4000.

**Формат вывода**:

Строка, содержащая число в десятичной системе счисления, соответствующее введённому.

**Sample Input 1**:

MCMLXXXIV

**Sample Output 1**:

1984

**Sample Input 2**:

IX

**Sample Output 2**:

9

**Sample Input 3**:

III

**Sample Output 3**:

3

```
from collections import OrderedDict as od
roman = input()
decimal = 0

d = (
        (900, 'CM'),
        (1000, 'M'),
        (400, 'CD'),
        (500, 'D'),
        (90, 'XC'),
        (100, 'C'),
        (40, 'XL'),
        (50, 'L'),
        (9, 'IX'),
        (10, 'X'),
        (4, 'IV'),
        (5, 'V'),
        (1, 'I')
    )

d = od(d)

for k in d:
    if roman.find(d[k]) >= 0:
        decimal += k * roman.count(d[k])
        roman = roman.replace(d[k], '')

print(decimal)
```

# 5.2 Old LCD calculator

Напишите программу, которая выводит число в стиле LCD калькулятора.

На вход программе подаётся последовательность цифр, которую нужно вывести на экран в специальном стиле (см. пример).

Размер всех цифр 4 символа в ширину и 7 символов в высоту. Между цифрами в выводе должен быть один пустой столбец. Перед первой цифрой не должно быть пробелов.

Выведенные цифры должны быть обведены рамочкой, в углах которой находится символ x ("икс"), горизонтальная линия создаётся из символа - ("дефис"), а вертикальная -- из символа вертикальной черты: |.

**Формат ввода**:

Строка произвольной длины (минимум один символ), содержащая последовательность цифр.

**Формат вывода**:

9 строк, содержащих цифры, записанные в указанном в задании формате.

**Sample Input**:

0123456789

**Sample Output**:

x-------------------------------------------------x
| --        --   --        --   --   --   --   -- |
||  |    |    |    | |  | |    |       | |  | |  ||
||  |    |    |    | |  | |    |       | |  | |  ||
|           --   --   --   --   --        --   -- |
||  |    | |       |    |    | |  |    | |  |    ||
||  |    | |       |    |    | |  |    | |  |    ||
| --        --   --        --   --        --   -- |
x-------------------------------------------------x

```
inp = list(map(lambda x: int(x), ''.join(input().split())))

aha = '    '
ahb = ' -- '
avb = '|   '
avc = '   |'
avd = '|  |'

d = {
     0:(ahb, avd, avd, aha, avd, avd, ahb),
     1:(aha, avc, avc, aha, avc, avc, aha),
     2:(ahb, avc, avc, ahb, avb, avb, ahb),
     3:(ahb, avc, avc, ahb, avc, avc, ahb),
     4:(aha, avd, avd, ahb, avc, avc, aha),
     5:(ahb, avb, avb, ahb, avc, avc, ahb),
     6:(ahb, avb, avb, ahb, avd, avd, ahb),
     7:(ahb, avc, avc, aha, avc, avc, aha),
     8:(ahb, avd, avd, ahb, avd, avd, ahb),
     9:(ahb, avd, avd, ahb, avc, avc, ahb)
    }

def print_border(l = len(inp)):
    print('x', end = '')
    print('-' * l * 5, end = '')
    print('x')

print_border()

for i in range(7):
    first = True
    for e in inp:
        if first: print ('|', end = '')
        print(d[e][i], end = ' ')
        first = False
    print('|')

print_border()
```

# 5.1 Collatz conjecture or the 3n + 1 problem - Шаг 1

Напишите функцию, которая для заданного натурального числа n генерирует последовательность чисел, описанную в гипотезе Коллатца:

Если n четное, то делим его пополам, если нечётное, то умножаем на 3 и прибавляем 1. С итогом вычисления снова проделываем эту операцию до тех пор, пока в результате не будет получено число 1.

Например, для числа n = 17 последовательность вычислений выглядит следующим образом:
17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1

Предполагается, что подобная последовательность остановится на числе 1 для любого начального натурального числа n. 

**Формат ввода**:

Строка, содержащая единственное целое число n, n > 0.

**Формат вывода**:

Строка, содержащая последовательность целых чисел, разделённых пробелом.

**Sample Input 1**:

17

**Sample Output 1**:

17 52 26 13 40 20 10 5 16 8 4 2 1

**Sample Input 2**:

1

**Sample Output 2**:

1

```
n = int(input())

def collatz(n):
    if n == 1:
        print(n, end = " ")
        return 1
    elif n % 2 == 0:
        print (n, end = " ")
        return collatz(n / 2)
    else:
        print (n, end = " ")
        return collatz(n * 3 + 1)

collatz(n)
```

# 4.4 Unicode Caesar cipher

Суть задачи та же, что и Caesar cipher, с одним отличием: кодируются символы из интервала 1F600—1F64F таблицы символов Юникода. Используется кодировка UTF-8.

Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита применить единичный сдвиг, то он заменится на первый символ, и наоборот.

Напишите программу, которая шифрует текст шифром Цезаря.

**Формат ввода**:
На первой строке указывается используемый сдвиг шифрования: целое число. Положительное число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования. 

**Формат вывода**:
Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри кавычек записана зашифрованная последовательность.

**Sample Input 1**:

1
😀🙏😇

**Sample Output 1**:

Result: "😁😀😈"

**Sample Input 2**:

1
😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙋🙌🙍🙎🙏

**Sample Output 2**:

Result: "😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙋🙌🙍🙎🙏😀"

**Вариант 1**:

```
n = int(input())
s = input()

def uni_caesar(s, n):
    res = ""
    initial = "".join([chr(x) for x in range(128512, 128592)])
    for e in s:
        res += initial[(initial.index(e) + n) % len(initial)]
    return "Result: \"%s\"" % res

print(uni_caesar(s, n))
```

**Вариант 2**:

```
n = int(input())
s = input()
initial = "".join([chr(x) for x in range(128512, 128592)])
offset = initial[n:] + initial[:n]
trantab = str.maketrans(initial, offset)
print("Result: \"%s\"" % s.translate(trantab))
```

# 4.3 Caesar cipher

Шифр Цезаря заключается в замене каждого символа входной строки на символ, находящийся на несколько позиций левее или правее его в алфавите.

Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита применить единичный сдвиг, то он заменится на первый символ, и наоборот.

Напишите программу, которая шифрует текст шифром Цезаря.

Используемый алфавит − пробел и малые символы латинского алфавита: ' abcdefghijklmnopqrstuvwxyz'

**Формат ввода**:
На первой строке указывается используемый сдвиг шифрования: целое число. Положительное число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования. Ведущие и завершающие пробелы не учитывать.

**Формат вывода**:
Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри кавычек записана зашифрованная последовательность.

**Sample Input 1**:

```
3
i am caesar
```

**Sample Output 1**:

`Result: "lcdpcfdhvdu"`

**Sample Input 2**:

```
-2
az
```

**Sample Output 2**:

`Result: "zx"`

**Sample Input 3**:

```
27
abc
```

**Sample Output 3**:

`Result: "abc"`

```
n = int(input())
s = input().strip()

def caesar(s, n):
    res = ""
    initial = " abcdefghijklmnopqrstuvwxyz"
    for e in s:
        res += initial[(initial.index(e) + n) % len(initial)]
    return "Result: \"%s\"" % res

print(caesar(s, n))
```

# 4.2 Base RLE decode

Кодирование длин серий — это базовый алгоритм сжатия данных.
В этой задаче мы реализуем алгоритм дешифровки строк, закодированных с помощью одного из самых простых  вариантов кодирования длин серий.
На вход алгоритму подаётся строка, содержащая цифры и символы латинского алфавита. Эта строка разбивается на так называемые "серии", которые кодируются парой число-символ или просто символ (в таком случае число считается равным единице). Результат должен содержать эти серии в том же порядке, что они и встречаются в исходной строке, при этом каждая серия раскрывается в последовательность символов соответствующей длины. 

Например, рассмотрим строку 

`3ab4c2CaB`

Разобъём её на серии

`3a b 4c 2C a B`

После чего преобразуем серии и получим исходную закодированную строку:

`aaabccccCCaB`

**Формат ввода**:

Одна строка, содержащая закодированную последовательность.

**Формат вывода**:

Строка, содержащая раскодированную последовательность.

**Sample Input**:

`3ab4c2CaB`

**Sample Output**:

`aaabccccCCaB`

```
s = input()
def rle_decode(s):
    repeat = ""
    res = ""
    for e in s:
        if e.isdigit():
            repeat += e
        else:
            if repeat:
                res += e * int(repeat)
            else:
                res += e
            repeat = ""
    return res
print(rle_decode(s))
```

# 4.1 Base RLE encode

Кодирование длин серий — это базовый алгоритм сжатия данных.
В этой задаче мы реализуем одну из самых простых его вариантов.
На вход алгоритму подаётся строка, содержащая символы латинского алфавита. Эта строка разбивается на группы одинаковых символов, идущих подряд ("серии"). Каждая серия характеризуется повторяющимся символом и количеством повторений. Именно эта информация и записывается в код: сначала пишется длина серии повторяющихся символов, затем сам символ. У серий длиной в один символ количество повторений будем опускать.
Например, рассмотрим строку

`aaabccccCCaB`

Разобъём её на серии

`aaa b cccc CC a B`

После чего закодируем серии и получим итоговую строку, которую и будем считать результатом работы алгоритма.

`3ab4c2CaB`

**Формат ввода**:

Одна строка, содержащая произвольные символы латинского алфавита.

**Формат вывода**:
Строка, содержащая закодированную последовательность.

**Sample Input 1**:

`aaabccccCCaB`

**Sample Output 1**:

`3ab4c2CaB`

**Sample Input 2**:

`a`

**Sample Output 2**:

`a`

```
s = input()

def rle_encode(s):
    res = ""
    counter = 1
    for i in range(len(s) - 1):
        if s[i] == s[i + 1]:
            counter += 1
        else:
            if counter == 1:
                res += s[i]
            else:
                res += str(counter) + s[i]
            counter = 1
    if len(s) > 0:
        if counter > 1:
            res += str(counter) + s[-1]
        else:
           res += s[-1]
    return res

print(rle_encode(s))
```

# 3.9 Duplicates in list

Напишите программу, которая принимает на вход список целых чисел и выводит на экран значения, которые повторяются в нём более одного раза.
Для решения задачи может пригодиться метод `sort` списка.

**Формат ввода**:

Одна строка с целыми числами, разделёнными пробелом.

**Формат вывода**:

Строка, содержащая числа, разделённые пробелом. Числа не должны повторяться, порядок вывода может быть произвольным.

**Sample Input**:

4 8 0 3 4 2 0 3

**Sample Output**:

0 3 4

```
l = input().split()
print(" ".join(list(set(filter(lambda x: l.count(x) > 1, l)))))
```

# 3.8 Spiral matrix

Выведите таблицу размером n × n, заполненную целыми числами от 1 до n**2 по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере.

**Формат ввода**:
Одна строка, содержащая одно целое число n, n > 0.

**Формат вывода**:
Таблица из n строк, значения в строках разделены пробелом.

**Sample Input**:

5

**Sample Output**:

```
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```
```
n = int(input())
a = [[0 for x in range(n)] for x in range(n)]
counter = 1
offset = 0

def right(i):
    global counter, offset
    j = offset
    while j < n - i and a[i][j] == 0:
        a[i][j] = counter
        j += 1
        counter += 1
    offset += 1

def down(i):
    global counter, offset
    j = offset
    while j < n - i and a[j][n - 1 - i] == 0:
        a[j][n - 1 - i] = counter
        j += 1
        counter += 1

def left(i):
    global counter, offset
    j = offset
    while j < n - i and a[n - 1 - i][n - 1 - j] == 0:
        a[n - 1 - i][n - 1 - j] = counter
        j += 1
        counter += 1

def up(i):
    global counter, offset
    j = offset
    while j < n - i and a[n - 1 - j][i] == 0:
        a[n - 1 - j][i] = counter
        j += 1
        counter += 1

for i in range(n):
    right(i)
    down(i)
    left(i)
    up(i)

for e in a:
    print(" ".join(map(lambda x: str(x), e)))
```

# 3.7 Multiple list index search

Напишите программу, которая принимает на вход список чисел и число, после чего выводит все позиции, на которых это число встречается в переданном списке.

Позиции в списке нумеруются с нуля.
Если число x не найдено в списке, нужно вывести строку "None" (без кавычек, с большой буквы).

**Формат ввода**:
На первой строке содержатся значения списка -- целые числа, разделённые пробелом. На второй строке содержится целое число, позиции которого нужно найти.

**Формат вывода**:
Одна строка, в которой содержится слово "None" или через пробел перечислены числа -- позиции, на которых число x встречается в списке lst. Позиции должны быть выведены в порядке возрастания.

**Sample Input 1**:

5 8 2 7 8 8 2 4

8

**Sample Output 1**:

1 4 5

**Sample Input 2**:

5 8 2 7 8 8 2 4

10

**Sample Output 2**:

None

```
a = input().split()
n = input()
res = [str(x[0]) for x in enumerate(a) if x[1] == n]
if len(res) == 0: print("None")
else: print(" ".join(res))
```

# 3.6 Number sequence

Напишите программу, которая выводит n первых элементов последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется столько раз, чему равно).

**Формат ввода**:
Строка, содержащая одно целое число n, n > 0

**Формат вывода**:
Строка, содержащая требуемую последовательность чисел, разделённых пробелом.

**Sample Input**:

7

**Sample Output**:

1 2 2 3 3 3 4

```
n = int(input())
res = ""
for i in range(n):
    if n == 1:
        print("1")
        break
    s = str(i) * i 
    res += s
    if len(res) >= n:
        print(" ".join(res[:n]))
        break
```

# 3.5 Cache function

Имеется реализованная функция f(x), принимающая на вход целое число x, которая вычисляет некоторое целочисленое значение и возвращает его в качестве результата работы.
Функция вычисляется достаточно долго, ничего не выводит на экран, не пишет в файлы и зависит только от переданного аргумента x.

Напишите программу, которая вычисляет значение этой функции для n чисел. 
Для ускорения вычисления необходимо сохранять уже вычисленные значения функции при известных аргументах.
Обратите внимание, что в этой задаче установлено достаточно сильное ограничение в две секунды по времени исполнения кода на тесте. 

**Формат ввода**:
На первой строке находится число n − количество значений, на которых нужно посчитать функцию. После этого следует n строк, на каждой строке по одному целому числу.

**Формат вывода**:
n строк, в каждой из которой результат вычисления функции на соответствующем аргументе.

**Sample Input**:

5

5

12

9

20

12

**Sample Output**:

11

41

47

61

41

```
n = int(input())
l = [int(input()) for x in range(n)]
res = []

for i in range(len(l)):
	if l[i] in l[:i]:
		idx = l.index(l[i])
		res.append(res[idx])
	else:
		res.append(f(l[i]))
	print(res[i])

```

# 3.4 Modify list

Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а чётные нацело делит на два. Функция не должна ничего возвращать, требуется только изменение переданного списка

```
def modify_list(l):
    idx = 0
    while idx < len(l):
        if l[idx] % 2:
            l.pop(idx)
        else:
            l[idx] = l[idx] // 2
            idx += 1
```
